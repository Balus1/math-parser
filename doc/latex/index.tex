\subsection*{D\-E\-S\-C\-R\-I\-P\-T\-I\-O\-N }

P\-H\-P parser and evaluator library for mathematical expressions.

Intended use\-: safe and reasonably efficient evaluation of user submitted formulas. The library supports basic arithmetic and elementary functions, as well as variables and extra functions.

The lexer and parser produces an abstract syntax tree (A\-S\-T) that can be traversed using a tree interepreter. The math-\/parser library ships with three interpreters\-:


\begin{DoxyItemize}
\item an evaluator computing the value of the given expression.
\item a differentiator transforming the A\-S\-T into a (somewhat) simplied A\-S\-T representing the derivative of the supplied expression.
\item a rudimentary La\-Te\-X output generator, useful for pretty printing expressions using Math\-Jax
\end{DoxyItemize}

\subsection*{E\-X\-A\-M\-P\-L\-E\-S }

It is possible to fine-\/tune the lexer and parser, but the library ships with a Std\-Math\-Parser class, capable of tokenizing and parsing standard mathematical expressions, including aritmethical operations as well as elementary functions.


\begin{DoxyCode}
use MathParser::StdMathParser;
use MathParser::Interpreting::Evaluator;

$parser = \textcolor{keyword}{new} StdMathParser();

\textcolor{comment}{// Generate an abstract syntax tree}
$AST = $parser->parse(\textcolor{stringliteral}{'1+2'});

\textcolor{comment}{// Do something with the AST, e.g. evaluate the expression:}
$evaluator = \textcolor{keyword}{new} Evaluator();

$value = $AST->accept($evaluator);
echo $value;
\end{DoxyCode}


More interesting example, containing variables\-:


\begin{DoxyCode}
$AST = $parser->parse(\textcolor{stringliteral}{'x+sqrt(y)'});

$evaluator->setVariables([ \textcolor{charliteral}{'x'} => 2, \textcolor{charliteral}{'y'} => 3 ]);
$value = $AST->accept($evaluator);
\end{DoxyCode}


We can do other things with the A\-S\-T. The library ships with a differentiator, computing the (symbolic) derivative with respect to a given variable.


\begin{DoxyCode}
use MathParser::Interpreting::Differentiator;

$differentiator = \textcolor{keyword}{new} Differentiator(\textcolor{charliteral}{'x'});
$f = $parser->parse(\textcolor{stringliteral}{'exp(2*x)-x*y'});
$df = $f->accept($differentiator);

\textcolor{comment}{// $df now contains the AST of '2*exp(x)-y' and can be evaluated further}
$evaluator->setVariables([ \textcolor{charliteral}{'x'} => 1, \textcolor{charliteral}{'y'} => 2 ]);
$df->accept($evaluator);
\end{DoxyCode}


\subsubsection*{Implicit multiplication}

Another helpful feature is that the parser understands implicit multiplication. An expression as {\ttfamily 2x} is parsed the same as {\ttfamily 2$\ast$x} and {\ttfamily xsin(x)cos(x)$^\wedge$2} is parsed as {\ttfamily x$\ast$sin(x)$\ast$cos(x)$^\wedge$2}.

Note that implicit multiplication has the same precedence as explicit multiplication. In particular {\ttfamily xy$^\wedge$2z} is parsed as {\ttfamily x$\ast$y$^\wedge$2$\ast$z} and {\bfseries not} as {\ttfamily x$\ast$y$^\wedge$(2$\ast$z)}.

To make full use of implicit multiplication, the standard lexer only allows one-\/letter variables. (Otherwise, we wouldn't know if {\ttfamily xy} should be parsed as {\ttfamily x$\ast$y} or as the single variable {\ttfamily xy}).

\subsection*{T\-H\-A\-N\-K\-S }

The Lexer is based on the lexer described by Marc-\/\-Oliver Fiset in his \href{http://marcofiset.com/programming-language-implementation-part-1-lexer/}{\tt blog}.

The parser is a version of the \char`\"{}\-Shunting yard\char`\"{} algorithm, described for example by \href{http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#shunting_yard}{\tt Theodore Norvell}. 